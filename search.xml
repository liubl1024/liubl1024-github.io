<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次 php 并发写入 顺序混乱的问题排查(下)</title>
      <link href="2021/04/25/php_file_put_contents_bing_fa_xie_ru_xia/"/>
      <url>2021/04/25/php_file_put_contents_bing_fa_xie_ru_xia/</url>
      
        <content type="html"><![CDATA[<p>上次我们说到  PHP 写入文件超过 8k 就不是原子操作而是会分批写入，我们用 C 做了试验，然而我意识到 其实里面有个错误， fputs 并不是一个系统调用，它是由 glibc C 实现的库函数，我们必须用 linux 提供给 C 的 write 函数 来测试。</p><p>我们 修改 write.c 文件 使用 write 函数</p><p>file: write</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sz<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"out.log"</span><span class="token punctuation">,</span>O_WRONLY <span class="token operator">|</span> O_CREAT <span class="token operator">|</span> O_APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">30000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token string">"abcd\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    sz <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"system call write(%d, \"buff \\n\", %d) return %d\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译并执行</p><pre class=" language-bash"><code class="language-bash">cc write.c -o <span class="token function">write</span><span class="token function">strace</span> ./write</code></pre><p>我们看到，这次经过了一次 系统调用</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>.open<span class="token punctuation">(</span><span class="token string">"out.log"</span>, O_WRONLY<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_APPEND, 03777767645557370<span class="token punctuation">)</span> <span class="token operator">=</span> 3write<span class="token punctuation">(</span>3, <span class="token string">"abcd\nabcd\nabcd\nabcd\nabcd\nabcd\nab"</span><span class="token punctuation">..</span>., 30000<span class="token punctuation">)</span> <span class="token operator">=</span> 30000fstat<span class="token punctuation">(</span>1, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFCHR<span class="token operator">|</span>0620, st_rdev<span class="token operator">=</span>makedev<span class="token punctuation">(</span>136, 3<span class="token punctuation">)</span>, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0<span class="token punctuation">..</span>.</code></pre><p>所以 之前 fputs 应该是C 库函数为写入速度做的优化。</p><p>我们再次看 write 的定义</p><p>man 2 write</p><pre><code>BUGS         top       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 ("Thread       Interactions with Regular File Operations"):           All of the following functions shall be atomic with respect           to each other in the effects specified in POSIX.1-2008 when           they operate on regular files or symbolic links: ...       Among the APIs subsequently listed are write() and writev(2).       And among the effects that should be atomic across threads (and       processes) are updates of the file offset.  However, on Linux       before version 3.14, this was not the case: if two processes that       share an open file description (see open(2)) perform a write()       (or writev(2)) at the same time, then the I/O operations were not       atomic with respect updating the file offset, with the result       that the blocks of data output by the two processes might       (incorrectly) overlap.  This problem was fixed in Linux 3.14.   &lt;---- 看这一行</code></pre><p>也就是说 linux 内核 3.14 之前 其实不是原子写入是存在bug，而之前测试的环境内核是 3.10.0</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@liubl ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># uname -a</span>Linux liubl 3.10.0-957.5.1.el7.x86_64 <span class="token comment" spellcheck="true">#1 SMP Fri Feb 1 14:54:57 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span></code></pre><p>通过查找 PHP 为什么做 超过 chunk_size 的优化 ，看到 php commit  中 php8 中已经取消了这个8192 分批写入的限制</p><p><a href="https://github.com/php/php-src/commit/5cbe5a538c92d7d515b0270625e2f705a1c02b18">https://github.com/php/php-src/commit/5cbe5a538c92d7d515b0270625e2f705a1c02b18</a></p><pre><code>Don't use chunking for stream writesWe're currently splitting up large writes into 8K size chunks, whichadversely affects I/O performance in some cases. Splitting up writesdoesn't make a lot of sense, as we already must have a backing buffer,so there is no memory/performance tradeoff to be made here.This change disables the write chunking at the stream layer, butretains the current retry loop for partial writes. In particularnetwork writes will typically only write part of the data for largewrites, so we need to keep the retry loop to preserve backwardscompatibility.If issues due to this change turn up, chunking should be reintroducedat lower levels where it is needed to avoid issues for specific streams,rather than unnecessarily enforcing it for all streams.</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liubl1024/blog_images/image/blog/image-20210427224212749.png" alt="image-20210427224212749"></p><p>因此我们可以安装 一个 php8  系统  内核 4.4  来测试</p><pre><code>root@ubuntu:~/test# uname -r4.4.0-62-genericroot@ubuntu:~/test# php -vPHP 8.0.3 (cli) (built: Mar  5 2021 07:53:39) ( NTS )Copyright (c) The PHP GroupZend Engine v4.0.3, Copyright (c) Zend Technologies    with Zend OPcache v8.0.3, Copyright (c), by Zend Technologies</code></pre><p>可以看到 写入也是 只进行了一次系统调用</p><p>file: chunk.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"type"</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">"report"</span><span class="token punctuation">,</span>    <span class="token string">"time"</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$data</span><span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$content</span> <span class="token operator">=</span> <span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span><span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"out.log"</span><span class="token punctuation">;</span><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$out</span><span class="token punctuation">,</span> <span class="token variable">$content</span><span class="token punctuation">,</span> <span class="token constant">FILE_APPEND</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>open("/root/test/out.log", O_WRONLY|O_CREAT|O_APPEND, 0666) = 3fstat(3, {st_mode=S_IFREG|0644, st_size=314800000, ...}) = 0lseek(3, 0, SEEK_CUR)                   = 0lseek(3, 0, SEEK_CUR)                   = 0write(3, "{\"type\":\"report\",\"time\":16192384"..., 30935) = 30935close(3)                                = 0close(2)                                = 0close(1)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>PHP 8 之前的版本 因为 file_put_contents 实现的原因，有  chunk_size 限制 所以 每次写入超过 8192，如果不加锁就存在混乱的可能，</p><p>而系统 linux  3.14 内核之前也有可能不是原子的写入过长数据也有可能混乱。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次 php 并发写入 顺序混乱的问题排查(上)</title>
      <link href="2021/04/23/php_file_put_contents_bing_fa_xie_ru_shang/"/>
      <url>2021/04/23/php_file_put_contents_bing_fa_xie_ru_shang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记一次 php  file_put_contents 并发写入  顺序混乱的问题排查</p></blockquote><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>事情是这样的，本来用 spark 跑采集的客户端日志，结果报错如下:</p><pre class=" language-bash"><code class="language-bash">WARN <span class="token punctuation">[</span>main<span class="token punctuation">]</span> DataSource: Found duplicate column<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> the data schema and the partition schema:  <span class="token variable"><span class="token variable">`</span>report_time<span class="token variable">`</span></span><span class="token punctuation">;</span>Exception <span class="token keyword">in</span> thread <span class="token string">"main"</span> org.apache.spark.sql.AnalysisException: Found duplicate column<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> the data schema: <span class="token variable"><span class="token variable">`</span>report_time<span class="token variable">`</span></span><span class="token punctuation">;</span></code></pre><h4 id="尝试搜索解决"><a href="#尝试搜索解决" class="headerlink" title="尝试搜索解决"></a>尝试搜索解决</h4><p>通过 搜索 大多数说法是日志中可能存在相同字段但是不同大小写的问题，只需要在代码中添加以下配置即可解决</p><pre class=" language-scala"><code class="language-scala">conf<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">"spark.sql.caseSensitive"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span></code></pre><p>但是添加完之后，依然报相同错误，经过一番推测 可能是源日志 有问题，于是写了 以下脚本来校验每行 <code>json</code> 是否完整</p><p>file: check.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$file</span> <span class="token operator">=</span> <span class="token string">"report.log"</span><span class="token punctuation">;</span><span class="token variable">$fd</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$row</span> <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">,</span><span class="token number">65535</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token function">json_decode</span><span class="token punctuation">(</span><span class="token variable">$row</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果有不完整的数据 或者解析 json 失败的数据 就打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">json_last_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"==============start={$i}=============\n"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token variable">$row</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string">"==============end==={$i}===========\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>得到输出如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>start<span class="token operator">=</span>586487<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">..</span>.   省略若干无用信息<span class="token string">"app_version"</span><span class="token keyword">:</span><span class="token string">"1.0.ice_model"</span><span class="token keyword">:</span><span class="token string">"V2049A"</span>, <span class="token punctuation">..</span>.   省略若干无用信息<span class="token punctuation">}</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>end<span class="token operator">==</span><span class="token operator">=</span>586487<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><p>可以看到 存在 这样的数据，明显是 并发写入时  json 被截断</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"app_version"</span><span class="token keyword">:</span><span class="token string">"1.0.ice_model"</span><span class="token keyword">:</span><span class="token string">"V2049A"</span>,</code></pre><p>一看不合理啊 客户端日志上报 是用 <code>file_put_centents</code> 写入的， 已经添加了  <code>FILE_APPEND</code> 参数，此参数 对应 系统调用的  <code>write</code> <code>O_APPEND</code> 参数，记得在 <code>APUE</code> 中 写到 <code>write</code>  加上  <code>O_APPEND</code> 参数 就能保证写入数据是原子的，不会互相覆盖，但是目前现象是 写入的数据乱序了。</p><h3 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h3><p>猜测可能是 并发写入时导致的，因此 通过 PHP <code>多进程 </code>并发写同一文件 测试来复现</p><h4 id="使用多进程复现"><a href="#使用多进程复现" class="headerlink" title="使用多进程复现"></a>使用多进程复现</h4><p>file:  pcntl_chunk.php</p><pre class=" language-php"><code class="language-php"><span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"out.log"</span><span class="token punctuation">;</span><span class="token variable">$content</span> <span class="token operator">=</span> <span class="token string">"record\n"</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token variable">$pid</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$c</span> <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token variable">$c</span><span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$out</span><span class="token punctuation">,</span> <span class="token variable">$content</span><span class="token punctuation">,</span> <span class="token constant">FILE_APPEND</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exit<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wc</span> -l out.log2000 out.log</code></pre><p>正常 应该输出 2000 行，多次测试 均无异常，但是线上收集客户端写入的日志里确实存在被截断的情况</p><p>干脆直接 通过  <code>strace</code> 命令，追踪 收集上报日志的  php-fpm 进程</p><p>假设  1234  为某个  php-fpm 进程 id</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">strace</span>  -p   1234</code></pre><p>可以看到以下输出</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>.  省略若干无用信息       open<span class="token punctuation">(</span><span class="token string">"/data/collect/zyj/2021/04/21"</span>, O_WRONLY<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_APPEND, 0666<span class="token punctuation">)</span> <span class="token operator">=</span> 5fstat<span class="token punctuation">(</span>5, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, st_size<span class="token operator">=</span>4360482272, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0lseek<span class="token punctuation">(</span>5, 0, SEEK_CUR<span class="token punctuation">)</span>                   <span class="token operator">=</span> 0lseek<span class="token punctuation">(</span>5, 0, SEEK_CUR<span class="token punctuation">)</span>                   <span class="token operator">=</span> 0write<span class="token punctuation">(</span>5, <span class="token string">"{\"type\":\"up\",\"time\":\"2021-0"</span><span class="token punctuation">..</span>., 8192<span class="token punctuation">)</span> <span class="token operator">=</span> 8192   <span class="token comment" spellcheck="true"># 可以看到这里  写入的日志 超过 8192 被分批写入</span>write<span class="token punctuation">(</span>5, <span class="token string">"755e18a\",\"ip\":\"127.0.0.0\",\""</span><span class="token punctuation">..</span>., 7263<span class="token punctuation">)</span> <span class="token operator">=</span> 7263    <span class="token comment" spellcheck="true"># 这里写入余下的数据</span>close<span class="token punctuation">(</span>5<span class="token punctuation">)</span>                                <span class="token operator">=</span> 0write<span class="token punctuation">(</span>4, <span class="token string">"\1\6\0\1\0T\4\0X-Powered-By: PHP/7.2.27"</span><span class="token punctuation">..</span>., 112<span class="token punctuation">)</span> <span class="token operator">=</span> 112shutdown<span class="token punctuation">(</span>4, SHUT_WR<span class="token punctuation">)</span>                    <span class="token operator">=</span> 0recvfrom<span class="token punctuation">(</span>4, <span class="token string">"\1\5\0\1\0\0\0\0"</span>, 8, 0, NULL, NULL<span class="token punctuation">)</span> <span class="token operator">=</span> 8recvfrom<span class="token punctuation">(</span>4, <span class="token string">""</span>, 8, 0, NULL, NULL<span class="token punctuation">)</span>       <span class="token operator">=</span> 0close<span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">..</span>.  省略若干无用信息</code></pre><p>仔细看上面注释，存在系统调用 <code>write</code> 文件时 长度大于 <code>8192</code> 也就是 8k  分批写入的情况，因此推测 刚刚复现的脚本中写入的数据长度不够，所以没有成功复现<br>我们加大 写入内容的长度，再次用 <code>strace</code> 观察 在系统调用 <code>write</code> 时是否是分批写入</p><p>file:chunk.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"type"</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">"report"</span><span class="token punctuation">,</span>    <span class="token string">"time"</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$data</span><span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$content</span> <span class="token operator">=</span> <span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span><span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"out.log"</span><span class="token punctuation">;</span><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$out</span><span class="token punctuation">,</span> <span class="token variable">$content</span><span class="token punctuation">,</span> <span class="token constant">FILE_APPEND</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>写入数据 长度为 30935 字节</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># php chunk.php</span>30935</code></pre><p>用 strace 执行可以看到如下输出</p><pre class=" language-bash"><code class="language-bash"><span class="token function">strace</span> php chunk.php</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>. <span class="token punctuation">..</span>. 省去无用信息lstat<span class="token punctuation">(</span><span class="token string">"/root/test/out.log"</span>, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, st_size<span class="token operator">=</span>12712298, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0open<span class="token punctuation">(</span><span class="token string">"/root/test/out.log"</span>, O_WRONLY<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_APPEND, 0666<span class="token punctuation">)</span> <span class="token operator">=</span> 3fstat<span class="token punctuation">(</span>3, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, st_size<span class="token operator">=</span>12712298, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0lseek<span class="token punctuation">(</span>3, 0, SEEK_CUR<span class="token punctuation">)</span>                   <span class="token operator">=</span> 0lseek<span class="token punctuation">(</span>3, 0, SEEK_CUR<span class="token punctuation">)</span>                   <span class="token operator">=</span> 0write<span class="token punctuation">(</span>3, <span class="token string">"{\"type\":\"report\",\"time\":16191055"</span><span class="token punctuation">..</span>., 8192<span class="token punctuation">)</span> <span class="token operator">=</span> 8192write<span class="token punctuation">(</span>3, <span class="token string">":359},{\"abc551\":207},{\"abc552\":5"</span><span class="token punctuation">..</span>., 8192<span class="token punctuation">)</span> <span class="token operator">=</span> 8192write<span class="token punctuation">(</span>3, <span class="token string">"225},{\"abc1091\":544},{\"abc1092\":"</span><span class="token punctuation">..</span>., 8192<span class="token punctuation">)</span> <span class="token operator">=</span> 8192write<span class="token punctuation">(</span>3, <span class="token string">"266},{\"abc1603\":422},{\"abc1604\":"</span><span class="token punctuation">..</span>., 6359<span class="token punctuation">)</span> <span class="token operator">=</span> 6359close<span class="token punctuation">(</span>3<span class="token punctuation">)</span>                                <span class="token operator">=</span> 0close<span class="token punctuation">(</span>2<span class="token punctuation">)</span>                                <span class="token operator">=</span> 0close<span class="token punctuation">(</span>1<span class="token punctuation">)</span>                                <span class="token operator">=</span> 0close<span class="token punctuation">(</span>0<span class="token punctuation">)</span>                                <span class="token operator">=</span> 0<span class="token punctuation">..</span>. <span class="token punctuation">..</span>. 省去无用信息</code></pre><p>可以看到  写入数据 分了五次  8192*3 + 6359 = 30935 刚好是我们写入的长度。</p><h3 id="再次复现"><a href="#再次复现" class="headerlink" title="再次复现"></a>再次复现</h3><p>用 多进程 加大写入数据长度 并发 写入 out.log 文件</p><p>file : pcntl_fork.php</p><pre class=" language-php"><code class="language-php"><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">"type"</span><span class="token operator">=</span><span class="token operator">></span><span class="token string">"report"</span><span class="token punctuation">,</span>    <span class="token string">"time"</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">"data"</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">2000</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$data</span><span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token operator">></span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$content</span> <span class="token operator">=</span> <span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$pid</span> <span class="token operator">=</span> <span class="token function">pcntl_fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token variable">$pid</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$c</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token variable">$c</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string">"out.log"</span><span class="token punctuation">;</span>            <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$out</span><span class="token punctuation">,</span> <span class="token variable">$content</span><span class="token punctuation">,</span> <span class="token constant">FILE_APPEND</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        exit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行  </p><pre class=" language-bash"><code class="language-bash">php  pcntl_fork.php</code></pre><p>用  check.php  检查 输出 out.log 输出 发现有以下内容</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>start<span class="token operator">=</span>94<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>abc293<span class="token string">":823},{"</span>abc294<span class="token string">":539},{"</span>abc29<span class="token punctuation">..</span>.<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>end<span class="token operator">==</span><span class="token operator">=</span>94<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span></code></pre><p>由此问题复现，可以得出结论，file_put_contents 时 如果只加 FILE_APPEND 参数，那么 写入长度 不大于 8k 时是原子写入，如果大于 8k 就不是原子，并发写入存在乱序的可能， 此时如果要杜绝这种情况 需要添加 LOCK_EX 参数。</p><p>一般情况 到这里就结束了，但是本着 刨根问底的思想，我们要一探究竟，为什么？ PHP 什么会出现这种情况，是内部 file_put_contents 实现的原因吗？  此时我们要到源码一探究竟</p><h3 id="查看源码-过程"><a href="#查看源码-过程" class="headerlink" title="查看源码 过程"></a>查看源码 过程</h3><h4 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/php/php-src/archive/refs/tags/php-7.4.18RC1.tar.gz<span class="token function">tar</span> xf php-7.4.18RC1.tar.gz<span class="token function">cd</span> php-7.4.18RC1</code></pre><h4 id="2-先找到-file-put-contents-定义"><a href="#2-先找到-file-put-contents-定义" class="headerlink" title="2. 先找到 file_put_contents 定义"></a>2. 先找到 file_put_contents 定义</h4><p>file : ext/standard/file.c</p><pre class=" language-c"><code class="language-c"><span class="token function">PHP_FUNCTION</span><span class="token punctuation">(</span>file_put_contents<span class="token punctuation">)</span><span class="token punctuation">{</span>    php_stream <span class="token operator">*</span>stream<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  省去无关代码        <span class="token keyword">case</span> IS_STRING<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Z_STRLEN_P</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ======================= ！！！ 主要看这里  !!! =================</span>                <span class="token comment" spellcheck="true">// ==========  file_put_contents 中 写入主要是 php_stream_write ==</span>                numbytes <span class="token operator">=</span> <span class="token function">php_stream_write</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token function">Z_STRVAL_P</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Z_STRLEN_P</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// ======================= ！！！ 主要看这里  !!! =================</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>numbytes <span class="token operator">!=</span> <span class="token function">Z_STRLEN_P</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">php_error_docref</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> E_WARNING<span class="token punctuation">,</span> <span class="token string">"Only %zd of %zd bytes written, possibly out of free disk space"</span><span class="token punctuation">,</span> numbytes<span class="token punctuation">,</span> <span class="token function">Z_STRLEN_P</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    numbytes <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  省去无关代码     <span class="token function">php_stream_close</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numbytes <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RETURN_FALSE<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="3-查看-php-stream-write-定义"><a href="#3-查看-php-stream-write-定义" class="headerlink" title="3. 查看  php_stream_write 定义"></a>3. 查看  php_stream_write 定义</h4><p>file : main/php_streams.h</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> php_stream_write(stream, buf, count)    _php_stream_write(stream, (buf), (count))</span></code></pre><h4 id="4-查看-php-stream-实现"><a href="#4-查看-php-stream-实现" class="headerlink" title="4. 查看 php_stream 实现"></a>4. 查看 php_stream 实现</h4><p>file: main/streams/streams.c</p><pre class=" language-c"><code class="language-c">PHPAPI ssize_t <span class="token function">_php_stream_write</span><span class="token punctuation">(</span>php_stream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">{</span>    ssize_t bytes<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                                                                                        <span class="token punctuation">}</span>    <span class="token function">ZEND_ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>ops<span class="token operator">-></span>write <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">php_error_docref</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> E_NOTICE<span class="token punctuation">,</span> <span class="token string">"Stream is not writable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>ssize_t<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-></span>writefilters<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                                         bytes <span class="token operator">=</span>          <span class="token function">_php_stream_write_filtered</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> PSFS_FLAG_NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ==========  这里 又跳到   _php_stream_write_buffer 函数</span>        bytes <span class="token operator">=</span> <span class="token function">_php_stream_write_buffer</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stream<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> PHP_STREAM_FLAG_WAS_WRITTEN<span class="token punctuation">;</span>    <span class="token punctuation">}</span>                                                                                                         <span class="token keyword">return</span> bytes<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="5-继续-看-php-stream-write-buffer-函数实现"><a href="#5-继续-看-php-stream-write-buffer-函数实现" class="headerlink" title="5. 继续 看 _php_stream_write_buffer 函数实现"></a>5. 继续 看 _php_stream_write_buffer 函数实现</h4><p>file : main/streams/streams.c</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Writes a buffer directly to a stream, using multiple of the chunk size */</span><span class="token keyword">static</span> ssize_t <span class="token function">_php_stream_write_buffer</span><span class="token punctuation">(</span>php_stream <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">{</span>    ssize_t didwrite <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> justwrote<span class="token punctuation">;</span>                                                                                                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  省略无关代码    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        size_t towrite <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ==================== !!!! 看这里  chunk_size 超过 chunk_size 会被截断 ================</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>towrite <span class="token operator">></span> stream<span class="token operator">-></span>chunk_size<span class="token punctuation">)</span>            towrite <span class="token operator">=</span> stream<span class="token operator">-></span>chunk_size<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ====================== chunk_size ===================</span>        justwrote <span class="token operator">=</span> stream<span class="token operator">-></span>ops<span class="token operator">-></span><span class="token function">write</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> towrite<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>justwrote <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                                                                    <span class="token comment" spellcheck="true">/* If we already successfully wrote some bytes and a write error occurred             * later, report the successfully written bytes. */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>didwrite <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> justwrote<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> didwrite<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 省略无关代码         <span class="token punctuation">}</span>    <span class="token keyword">return</span> didwrite<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-查看-chunk-size-大小"><a href="#6-查看-chunk-size-大小" class="headerlink" title="6. 查看  chunk_size 大小"></a>6. 查看  chunk_size 大小</h4><p>在  php_stream 定义</p><p>file:   main/php_streams.h</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _php_stream php_stream<span class="token punctuation">;</span></code></pre><p>file:  main/php_streams.h</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> _php_stream  <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">/* how much data to read when filling buffer */</span>    size_t chunk_size<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span></code></pre><p>我们 看到 chunk_size 大小 由  size_t  决定，根据 系统实现 在 64 位系统中为 8k 长度即为 8192 , 这就可以看到 file_put_contents 如果大于 8k 就不是一个系统调用了， 因此不是原子的，不加锁的情况 会乱序。</p><p>那么为什么 file_put_contents 要限制 写入 大小超过 size_t 要分批呢，是PHP 独有的还是 其它语言也有这个问题  ?</p><h3 id="其它语言是否有这个问题？"><a href="#其它语言是否有这个问题？" class="headerlink" title="其它语言是否有这个问题？"></a>其它语言是否有这个问题？</h3><p>我们接着以  C 语言查看是否有同样现象</p><p>file : write.c</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token function">strcat</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> <span class="token string">"abcdef\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"c_out.log"</span><span class="token punctuation">,</span> O_CREAT<span class="token operator">|</span>O_APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fputs</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译执行</p><pre class=" language-bash"><code class="language-bash">cc  write.c  -o <span class="token function">write</span><span class="token function">strace</span> <span class="token function">write</span></code></pre><pre class=" language-bash"><code class="language-bash">open<span class="token punctuation">(</span><span class="token string">"c_out.log"</span>, O_RDWR<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_TRUNC, 0666<span class="token punctuation">)</span> <span class="token operator">=</span> 3fstat<span class="token punctuation">(</span>3, <span class="token punctuation">{</span>st_mode<span class="token operator">=</span>S_IFREG<span class="token operator">|</span>0644, st_size<span class="token operator">=</span>0, <span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> 0mmap<span class="token punctuation">(</span>NULL, 4096, PROT_READ<span class="token operator">|</span>PROT_WRITE, MAP_PRIVATE<span class="token operator">|</span>MAP_ANONYMOUS, -1, 0<span class="token punctuation">)</span> <span class="token operator">=</span> 0x7f5b4d4b2000write<span class="token punctuation">(</span>3, <span class="token string">"abcdef\nabcdef\nabcdef\nabcdef\nabcd"</span><span class="token punctuation">..</span>., 8192<span class="token punctuation">)</span> <span class="token operator">=</span> 8192write<span class="token punctuation">(</span>3, <span class="token string">"cdef\nabcdef\nabcdef\nabcdef\nabcdef"</span><span class="token punctuation">..</span>., 1812<span class="token punctuation">)</span> <span class="token operator">=</span> 1812close<span class="token punctuation">(</span>3<span class="token punctuation">)</span>                                <span class="token operator">=</span> 0munmap<span class="token punctuation">(</span>0x7f5b4d4b2000, 4096<span class="token punctuation">)</span>            <span class="token operator">=</span> 0exit_group<span class="token punctuation">(</span>0<span class="token punctuation">)</span>                           <span class="token operator">=</span> ?</code></pre><p>可以看到 C 语言中 <code>write</code>  超过 8k 也会拆分，看来不是 php 独有的问题，是系统的问题。</p><p>为什么系统调用 <code>wirte</code> 时 超过 8k 就会不是原子操作， 这个问题我们下篇文章继续探讨。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么TCP会粘包，而HTTP不会</title>
      <link href="2021/04/10/wei_shi_me_tcp_hui_nian_bao_er_http_bu_hui/"/>
      <url>2021/04/10/wei_shi_me_tcp_hui_nian_bao_er_http_bu_hui/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么TCP-会粘包，而HTTP-不会"><a href="#为什么TCP-会粘包，而HTTP-不会" class="headerlink" title="为什么TCP 会粘包，而HTTP 不会"></a>为什么TCP 会粘包，而HTTP 不会</h3><h4 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h4><p>​      粘包是在 客户端和服务端收发数据过程中，发生数据包粘连在一块无法区分，下面来看个例子</p><p>TCP 服务端使用 PHP 监听 8000 端口</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$ip</span> <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">;</span><span class="token variable">$port</span> <span class="token operator">=</span> <span class="token string">"8000"</span><span class="token punctuation">;</span><span class="token variable">$recv_len</span> <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span><span class="token variable">$serv</span> <span class="token operator">=</span> <span class="token function">socket_create</span><span class="token punctuation">(</span><span class="token constant">AF_INET</span><span class="token punctuation">,</span> <span class="token constant">SOCK_STREAM</span><span class="token punctuation">,</span> <span class="token constant">SOL_TCP</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token function">socket_last_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建</span><span class="token function">socket_bind</span><span class="token punctuation">(</span><span class="token variable">$serv</span><span class="token punctuation">,</span> <span class="token variable">$ip</span><span class="token punctuation">,</span> <span class="token variable">$port</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">socket_listen</span><span class="token punctuation">(</span><span class="token variable">$serv</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$cli</span> <span class="token operator">=</span> <span class="token function">socket_accept</span><span class="token punctuation">(</span><span class="token variable">$serv</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$msg</span> <span class="token operator">=</span> <span class="token function">socket_read</span><span class="token punctuation">(</span><span class="token variable">$cli</span><span class="token punctuation">,</span><span class="token variable">$recv_len</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">"收到 数据: {$msg}\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">socket_getsockname</span><span class="token punctuation">(</span><span class="token variable">$cli</span><span class="token punctuation">,</span> <span class="token variable">$cli_addr</span><span class="token punctuation">,</span> <span class="token variable">$cli_port</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$send_msg</span> <span class="token operator">=</span> <span class="token string">"[发送数据]"</span><span class="token punctuation">;</span>        <span class="token function">socket_write</span><span class="token punctuation">(</span><span class="token variable">$cli</span><span class="token punctuation">,</span> <span class="token variable">$send_msg</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$send_msg</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">socket_close</span><span class="token punctuation">(</span><span class="token variable">$cli</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">socket_close</span><span class="token punctuation">(</span><span class="token variable">$serv</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>client 使用 go 发送数据</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"net"</span><span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">import</span> <span class="token string">"time"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"[我爱中国]"</span><span class="token punctuation">)</span>    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialTimeout</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:8000"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"连接失败, err : %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"写入失败, err : %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code># php tcp_server.php收到 数据: [我爱中国][我爱中收到 数据: 国][我爱中国][我�收到 数据: �中国][我爱中国][�收到 数据: ��爱中国][我爱中�收到 数据: �][我爱中国][我爱�收到 数据: ��国][我爱中国]</code></pre><p>可以看到 数据包粘连在一块无法区分的现象。形成这种现象的原因可以先看TCP 的定义</p><p>TCP/IP (Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接的、可靠的、基于字节流的传输层（Transport layer）通信协议。</p><p>TCP （Transmission Control Protocol）协议即传输控制协议，根据  OSI 网络分层模型</p><p><img src="https://cdn.jsdelivr.net/gh/liubl1024/blog_images/image/blog/o1.png" alt="OSI七层模型| KEEM--BLOG"></p><p>TCP 是四层即传输层协议，TCP 层，通过包序列号，确认应答等方式保证数据传输的可靠，TCP 只保证数据的传输可靠，但是对于同时发送多条数据来说 对TCP 而已只是一条数据流，TCP 层本身是不会去区分数据边界，数据边界是要靠上层协议，即应用层区分。</p><h4 id="HTTP-协议为什么没有粘包问题"><a href="#HTTP-协议为什么没有粘包问题" class="headerlink" title="HTTP 协议为什么没有粘包问题"></a>HTTP 协议为什么没有粘包问题</h4><p>HTTP 协议是应用层协议，我们用 curl 开看 HTTP 的请求返回，以访问百度为例</p><pre class=" language-bash"><code class="language-bash">$ curl -v http://www.baidu.com*   Trying 220.181.38.150<span class="token punctuation">..</span>.* TCP_NODELAY <span class="token keyword">set</span>* Connected to www.baidu.com <span class="token punctuation">(</span>220.181.38.150<span class="token punctuation">)</span> port 80 <span class="token punctuation">(</span><span class="token comment" spellcheck="true">#0)</span><span class="token operator">></span> GET / HTTP/1.1<span class="token operator">></span> Host: www.baidu.com<span class="token operator">></span> User-Agent: curl/7.64.1<span class="token operator">></span> Accept: */*<span class="token operator">></span><span class="token operator">&lt;</span> HTTP/1.1 200 OK<span class="token operator">&lt;</span> Accept-Ranges: bytes<span class="token operator">&lt;</span> Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform<span class="token operator">&lt;</span> Connection: keep-alive<span class="token operator">&lt;</span> Content-Length: 2381<span class="token operator">&lt;</span> Content-Type: text/html<span class="token operator">&lt;</span> Date: Fri, 09 Apr 2021 16:26:59 GMT<span class="token operator">&lt;</span> Etag: <span class="token string">"588604c8-94d"</span><span class="token operator">&lt;</span> Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT<span class="token operator">&lt;</span> Pragma: no-cache<span class="token operator">&lt;</span> Server: bfe/1.0.8.18<span class="token operator">&lt;</span> Set-Cookie: BDORZ<span class="token operator">=</span>27315<span class="token punctuation">;</span> max-age<span class="token operator">=</span>86400<span class="token punctuation">;</span> domain<span class="token operator">=</span>.baidu.com<span class="token punctuation">;</span> path<span class="token operator">=</span>/<span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>--STATUS OK--<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span> <span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span>content-type content<span class="token operator">=</span>text/html<span class="token punctuation">;</span>charset<span class="token operator">=</span>utf-8<span class="token operator">></span><span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span>X-UA-Compatible content<span class="token operator">=</span>IE<span class="token operator">=</span>Edge<span class="token operator">></span><span class="token operator">&lt;</span>meta content<span class="token operator">=</span>always name<span class="token operator">=</span>referrer<span class="token operator">></span><span class="token operator">&lt;</span>link rel<span class="token operator">=</span>stylesheet type<span class="token operator">=</span>text/css href<span class="token operator">=</span>http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css<span class="token operator">></span><span class="token operator">&lt;</span>title<span class="token operator">></span>百度一下，你就知道<span class="token operator">&lt;</span>/title<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span></code></pre><p>根据HTTP 协议定义，请求和响应都分为  <code>http head</code> 和 <code>http body</code> ，http head 和 body 通过 <code>\r\n</code> 区分，我们可以看到 在http  包头里 有 <code>content-length</code> 字段，``content-length` 用来确定 包体的长度，因此就可以划分哪些数据应该是一个请求中的，达到区分的目的。</p><p>参考HTTP 协议，一般 TCP 层 避免粘包，区分数据包主要有两种方式</p><ol><li>固定包头</li><li>固定分隔符</li></ol><h3 id="固定包头"><a href="#固定包头" class="headerlink" title="固定包头"></a>固定包头</h3><p>一般通用方式，固定包头 及 数据包的前几个字节 包含 数据包长度等信息，在处理中可以先读前几个字节，获取长度和其它扩展信息等，来确定后面包体的长度</p><h4 id="固定分隔符"><a href="#固定分隔符" class="headerlink" title="固定分隔符"></a>固定分隔符</h4><p>即类似 HTTP 区分包头和包体的方式 用类似 \r\n 的方式来区分数据包</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> HTTP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊接口幂等性</title>
      <link href="2021/02/08/liao_yi_liao_jie_kou_mi_deng_xing/"/>
      <url>2021/02/08/liao_yi_liao_jie_kou_mi_deng_xing/</url>
      
        <content type="html"><![CDATA[<p>回想曾经刚来北京，去某厂面试，前面聊得还不错，后面突然被问到幂等性问题，当时从二线城市出来，完全没听过这个名词有点懵，没答上来，明显感觉面试官态度有所变化。面试结束后一查才知道，平时开发过程中防止用户重复点击等场景，其实已经用到过就是不知道这个名词。</p><p>幂等性其实就是多次调用接口返回值和影响结果与单次调用的返回值和影响相同。</p><p>拿类似微博的系统来说，如果查看某个人的微博，查询一次和查询多次结果是一样的，并且都不会影响数据库中关于这条微博的存储结果。</p><p>因此可以说，查询天生就是幂等性的， 在 <code>Restful</code> 中 即  GET 是幂等性。</p><pre class=" language-bash"><code class="language-bash">GET  http://somesite.com/?id<span class="token operator">=</span>1    <span class="token comment" spellcheck="true"># 多次调用 对后端无影响</span></code></pre><p>如果作为用户，发一条微博，由于手抖或者网络波动重试而发出去了多条相同的微博，那么此时肯定不是我们想要的结果，所以新增不是幂等性的。</p><pre class=" language-bash"><code class="language-bash">POST   http://somesite.com/weibo     <span class="token comment" spellcheck="true"># 多次调用会生成多条记录</span></code></pre><p>修改和删除也类似，加入某个用户要加经验或金币，一般不会用  update set 具体值操作，而是使用  += ，那么多次修改金币或经验数肯定对不上了。</p><p>删除虽说 一般标记 状态 <code> is_del  = true</code>  的假删除  ，但是对同一 id 多次请求 <code>DELETE</code>  返回结果可能是不一样的。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>其实解决办法基本上都能想到，就是用  token 或叫做 noceid 的字符串来标记请求，如果第一次处理成功就记录 token 和返回结果，如果处理失败就立即删除 token ，后面如果有相同 token 和参数的请求就直接返回 记录的结果。token 最好客户端生成，因为服务端很难区分是真实的需要新增或修改多条数据还是由于某些原因重复发送的数据</p><p>生成 token 得注意：</p><p>token 尽可能<strong>唯一</strong>， token 一般是客户端生成，因此可以利用客户端的信息元素 加时间戳等 算法来保证唯一</p><p>一般来说用 redis 来存储比较合适，因为 redis 是单线程，第一个请求到来后，可以马上把 token 放到 <code>string</code> 中存储，系统开销也会较小。</p><p>几个常用 设计幂等操作的方法</p><ol><li><p>利用数据库的唯一约束实现</p><p> mysql    insert if not exist</p><p> redis   setnx 代替</p></li><li><p>为更新的数据设置前置条件</p><p> “将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性</p><p> 例如更新前  查询 select   …  for update</p><p> 数据增加版本号属性 </p></li><li><p>记录并检查操作</p><p> 也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作</p><p> 记录并检查操作，在每个消息中维护一个全局唯一的ID，根据全局唯一ID进行判断消息是否已经被消费。存在的问题，全局唯一ID的实现有一定的复杂度，需要确保检查消费状态、更新数据、以及更新消费状态三个操作原子性，解决方式涉及到分布式锁和分布式事务，并且对高性能、高并发也有一定的影响</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 远程执行多条耗时命令</title>
      <link href="2021/01/27/php_yuan_cheng_zhi_xing_duo_tiao_hao_shi_ming_ling/"/>
      <url>2021/01/27/php_yuan_cheng_zhi_xing_duo_tiao_hao_shi_ming_ling/</url>
      
        <content type="html"><![CDATA[<p>本文介绍 PHP 用ssh 的方式远程执行任务的办法</p><p>开发中有时需要用 ssh 远程连接到其它服务器执行任务脚本，在 PHP 中虽然有 ssh 扩展 或是封装的 ssh 操作的包 phpseclib。</p><p>简单使用了下 他们，发现如果是执行短时间就能完成的命令，基本能满足需求。但是如果执行耗时较长的命令时，由于网络抖动或其他原因连接意外断开，那么此时 php 并不会捕获异常而是会陷入假死状态，通过  ps  aux | grep  ssh.php 查看如下</p><pre class=" language-bash"><code class="language-bash">root       7156   0.0  0.0  4341748   7228 s005  S+   11:28下午   0:00.06 php ssh.php</code></pre><p>可以发现此时状态是 S+ ，看起来是一切正常，但是手动连接要执行任务的机器可能发现任务已经终止，SSH 一般的客户端来说是可以设置 心跳时间的，但是由于 PHP 的ssh 扩展没有心跳时间等参数，导致连接如果时间长，没有发送心跳，很容易被系统认为连接已经中断而关闭连接，此时如果单纯用PHP 的话很难解决。</p><p>一般可以想到使用 nohup 的方式</p><pre class=" language-bash"><code class="language-bash"><span class="token function">nohup</span>  ./task.sh  <span class="token operator">></span> /dev/null 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span> </code></pre><p>通过 nohup 会拿到 tash.sh 的进程id，可以定时来检测 进程id 是否存在而判断任务是否结束，但是进程如果发生异常而退出就无法检测到</p><p>可以把标准错误输出到 err.log 中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">nohup</span> ./test.sh <span class="token operator">></span> /dev/null  2<span class="token operator">></span>/tmp/err.log <span class="token operator">&amp;</span> </code></pre><p>此时可以通过查看 /tmp/err.log 中的内容来判断是否正常执行，但是如果要执行一系列命令的情况，一个个处理将会非常麻烦。</p><p>一般这种情况可以通过 委托给 agent 的方式来执行，但是如果没有 agent 仅仅执行几个命令单独再实现一个agent 部署到每台执行任务的机器的成本略高。</p><p>我们都知道 Linux 命令成功或失败是有标准输出和错误输出的那么就可以利用这个特性，执行完任务无论成功或失败就给个回调地址</p><p>用 shell 脚本如下</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>cmd<span class="token operator">=</span><span class="token string">'ls -al'</span>callback_url<span class="token operator">=</span><span class="token string">"http://abc.com"</span>success<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    curl  <span class="token string">"<span class="token variable">$callback_url?</span>&amp;result=success&amp;task_id={<span class="token variable">$task_id</span>}"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>error<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$*</span><span class="token punctuation">;</span>    curl  -g <span class="token string">"<span class="token variable">$callback_url?</span>&amp;result=failed&amp;msg=\<span class="token variable">$*</span>&amp;task_id={<span class="token variable">$task_id</span>}"</span><span class="token punctuation">;</span>    <span class="token keyword">exit</span> -1<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token variable">$cmd</span><span class="token punctuation">}</span> 2<span class="token operator">></span>/tmp/err.out<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"\<span class="token variable">$?</span>"</span> -ne 0 <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>    error_info<span class="token operator">=</span>`cat <span class="token string">'/tmp/err.out'</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token string">"\\n"</span> <span class="token string">" "</span> `    error <span class="token function">exec</span> <span class="token punctuation">{</span><span class="token variable">$cmd</span><span class="token punctuation">}</span> \<span class="token variable">${error_info}</span><span class="token keyword">fi</span>    success <span class="token string">"success"</span></code></pre><p>基于上面这个shell 脚本，就可以通过 PHP 构造一个函数来生成多条命令的脚本</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">/** * @param $callbackUrl string  回调地址 * @param $cmds array 执行命令的数组 **/</span><span class="token keyword">function</span> <span class="token function">makeMultiCmdShell</span><span class="token punctuation">(</span><span class="token variable">$callbackUrl</span><span class="token punctuation">,</span><span class="token variable">$cmds</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$callbackUrl</span><span class="token punctuation">;</span>               <span class="token variable">$bash_content</span><span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token constant">EOF</span><span class="token shell-comment comment">#!/bin/bash</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    curl  <span class="token string">"$callback_url?&amp;result=success&amp;task_id={$task_id}"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> \$<span class="token operator">*</span><span class="token punctuation">;</span>    curl  <span class="token operator">-</span>g <span class="token string">"$callback_url?&amp;result=failed&amp;msg=\$*&amp;task_id={$task_id}"</span><span class="token punctuation">;</span>    exit <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token constant">EOF</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$cmds</span> <span class="token keyword">as</span> <span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$bash_content</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token constant">EOF</span>    <span class="token punctuation">{</span><span class="token variable">$cmd</span><span class="token punctuation">}</span> <span class="token number">2</span><span class="token operator">></span><span class="token operator">/</span>tmp<span class="token operator">/</span>err<span class="token punctuation">.</span>out<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"\$?"</span> <span class="token operator">-</span>ne <span class="token number">0</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> then    error_info<span class="token operator">=</span>`cat <span class="token string">'/tmp/err.out'</span> <span class="token operator">|</span> tr <span class="token string">"\\n"</span> <span class="token string">" "</span> `    error exec <span class="token punctuation">{</span><span class="token variable">$cmd</span><span class="token punctuation">}</span> \$<span class="token punctuation">{</span>error_info<span class="token punctuation">}</span>fi<span class="token constant">EOF</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$bash_content</span> <span class="token punctuation">.</span><span class="token operator">=</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token constant">EOF</span>    success <span class="token string">"success"</span><span class="token constant">EOF</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> <span class="token variable">$bash_content</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过这个函数就可以得到一个 shell 脚本，放到远程服务器后 通过 nohup 执行，就可以不用一直轮询它的执行状态，等待回调消息即可，</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> SHELL </tag>
            
            <tag> LINUX </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 误删库了怎么办</title>
      <link href="2021/01/23/mysql_wu_shan_ku_liao_zen_me_ban/"/>
      <url>2021/01/23/mysql_wu_shan_ku_liao_zen_me_ban/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MySQL 由于没加条件更新了全表数据，或者误删库后只能跑路吗？显然不是的，本文简单谈谈MySQL 的备份、恢复策略。</p></blockquote><h4 id="一般情况下MySQL-的备份分为以下几种："><a href="#一般情况下MySQL-的备份分为以下几种：" class="headerlink" title="一般情况下MySQL 的备份分为以下几种："></a>一般情况下MySQL 的备份分为以下几种：</h4><ul><li><p>逻辑备份</p></li><li><p>物理备份</p></li><li><p>lvm 快照备份</p></li><li><p>主从备份</p></li></ul><p> 逻辑备份就是 用mysqldump 工具定期导出sql，这种方式的优点是灵活、文本储存，有许多参数可供选择并且可直接查看数据信息。缺点是备份时间较长，备份时占用服务器资源较大，因此推荐在系统不繁忙时备份。</p><p>物理备份是直接打包 数据库的 data 目录 文件，优点是快，缺点是备份的数据易损坏，备份时需要给加锁，防止新数据写入。</p><p>lvm 是 linux 直接复制磁盘快照的方式备份 MySQL。</p><p>主从备份是通过 设置 MySQL 主从延迟时间的方式达到备份的目的，在主库误操作之后，只要误操作还没同步到从库，就可以通过 stop slave 的方式，停止从库的复制，这时只需要把库切换为从库就达到恢复的目的。</p><p>有备份当然可以恢复，如果没有备份策略 可以通过 mysqlbinlog 来恢复，mysqlbinlog  需要 开启 binlog 参数</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[mysqld]</span># binlog 日志路径配置<span class="token constant">log-bin</span> <span class="token attr-value"><span class="token punctuation">=</span> /etc/mysql/logs/mysql-bin.log</span># binlog 有效期<span class="token constant">expire-logs-days</span> <span class="token attr-value"><span class="token punctuation">=</span> 14</span># 单文件最大大小<span class="token constant">max-binlog-size</span> <span class="token attr-value"><span class="token punctuation">=</span> 500M </span><span class="token constant">server-id</span> <span class="token attr-value"><span class="token punctuation">=</span> 1 </span></code></pre><p> MySQL 的binlog 文件  可以通过以下命令来查看</p><pre class=" language-bash"><code class="language-bash">mysqlbinlog --no-defaults  -v -v  --base64-output<span class="token operator">=</span>DECODE-ROWS  mysql-bin.000001</code></pre><p>mysql-bin.000001 为当前要查看的binlog文件，也可以添加 -d 参数查看指定的库的binlog </p><p>binlog 文件中有 at  1089695  及日志的记录点，和时间 #210109 14:57:42 如下：</p><pre class=" language-bash"><code class="language-bash">BEGIN/*<span class="token operator">!</span>*/<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># at 1089695</span><span class="token comment" spellcheck="true"># at 1089904</span><span class="token comment" spellcheck="true">#210109 14:57:42 server id 1  end_log_pos 1089935 CRC32 0x3d0263c0   Xid = 17531684</span>COMMIT/*<span class="token operator">!</span>*/<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># at 1089935</span><span class="token comment" spellcheck="true">#210109 14:57:42 server id 1  end_log_pos 1090000 CRC32 0x8be6bcd5   Anonymous_GTID  last_committed=1844  sequence_number=1845  rbr_only=no  original_committed_timestamp=0  immediate_commit_timestamp=0  transaction_length=0</span><span class="token comment" spellcheck="true"># original_commit_timestamp=0 (1970-01-01 08:00:00.000000 CST)</span><span class="token comment" spellcheck="true"># immediate_commit_timestamp=0 (1970-01-01 08:00:00.000000 CST)</span>/*<span class="token operator">!</span>80001 SET @@session.original_commit_timestamp<span class="token operator">=</span>0*//*<span class="token operator">!</span>*/<span class="token punctuation">;</span>/*<span class="token operator">!</span>80014 SET @@session.original_server_version<span class="token operator">=</span>0*//*<span class="token operator">!</span>*/<span class="token punctuation">;</span>/*<span class="token operator">!</span>80014 SET @@session.immediate_server_version<span class="token operator">=</span>0*//*<span class="token operator">!</span>*/<span class="token punctuation">;</span>SET @@SESSION.GTID_NEXT<span class="token operator">=</span> <span class="token string">'ANONYMOUS'</span>/*<span class="token operator">!</span>*/<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># at 1090000</span><span class="token comment" spellcheck="true">#210109 14:57:42 server id 1  end_log_pos 1090083 CRC32 0xb6986227   Query  thread_id=435893  exec_time=0  error_code=0</span></code></pre><p>MySQL 可以通过 指定 –start-datetime    –stop-datetime  来恢复指定时间点的数据，或者 –start-position     –stop-position 恢复指定位置的数据。</p><p>一般运维所说 数据库可以恢复到 一周内任意一个时间点的数据，即数据库按周逻辑备份，和 binlog 结合的方式。</p><p>还有一些闪回工具，例如美团开源的 MyFlash 就是基于 binlog 的反向操作，即 insert 一条数据，反向操作就是 delete 。</p><p>另外 一定要做好MySQL 的安全管理，例如权限分配，普通登录用户不开删库的权限，MySQL 还有一个 sql_safe_updates 参数，可以有效限制不带 where 条件的 delete 和 update 语句是无法执行的，MySQL 一定要加这个参数来保证安全，如果开发中有需求要删除整张表，可以通过以下流程删除：</p><h1 id="先备份表"><a href="#先备份表" class="headerlink" title="先备份表"></a>先备份表</h1><pre><code>create table table_bak like drop_table；insert into table_bak select * from drop_table；</code></pre><h1 id="临时关闭-sql-safe-并删除"><a href="#临时关闭-sql-safe-并删除" class="headerlink" title="临时关闭 sql_safe 并删除"></a>临时关闭 sql_safe 并删除</h1><pre><code>set session sql_safe_updates=0;drop table drop_table;set session sql_safe_updates=1;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 一键部署发布上线</title>
      <link href="2021/01/23/vue_yi_jian_bu_shu_fa_bu_shang_xian/"/>
      <url>2021/01/23/vue_yi_jian_bu_shu_fa_bu_shang_xian/</url>
      
        <content type="html"><![CDATA[<p> 一般来说软件开发流程规范的公司会有标准 CI/CD 流程，本文不谈 Jenkins 或是git hook 等工具，介绍两种在小项目中最快也最原始的方式一键打包上线的方式。</p><ul><li> webpack-sftp-client</li><li> shell  expect</li></ul><p>​    webpack-sftp-client，使用步骤如下：</p><ol><li>安装</li></ol><pre><code>npm install webpack-sftp-client -D</code></pre><ol start="2"><li>在 webpack.dev.js webpack.prod.js 中引入并配置</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> WebpackSftpClient <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-sftp-client'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">WebpackSftpClient</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  port<span class="token punctuation">:</span> <span class="token string">'22'</span><span class="token punctuation">,</span>  host<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 服务器ip</span>  username<span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 用户名</span>  password<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 密码</span>  path<span class="token punctuation">:</span> <span class="token string">'./test/'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 本地路径</span>  remotePath<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 远端服务器路径</span>  verbose<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>然后 使用 npm run prod  或者 npm run dev 打包后就会自动上线了。</p><p>shell 的方式 就是通过编写 shell 脚本的形式，如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># 服务器ip</span>serverIp<span class="token operator">=</span><span class="token string">""</span><span class="token comment" spellcheck="true"># 服务器存放目录</span>dstDir<span class="token operator">=</span><span class="token string">""</span><span class="token function">npm</span> run prod<span class="token function">zip</span> -r dist.zip dist<span class="token function">scp</span> dist.zip root@<span class="token variable">${serverIp}</span><span class="token keyword">:</span><span class="token variable">${dstDir}</span><span class="token function">ssh</span>  root@<span class="token variable">${serverIp}</span>  <span class="token string">"cd <span class="token variable">${dstDir}</span>; unzip -o dist.zip"</span></code></pre><p>这种方式 需要提前使用 ssh-copy-id 打通 ssh 免密登陆，如果开发机是临时申请或 ip 变动频繁，那么每次都要配置免密登陆无疑是非常麻烦的事情，作为开发者如果是重复的事情肯定要自动化。</p><p>  一般来说 临时申请的机器 密码不会频繁变更，因此可以通过输入密码的方式，但是 ssh 密码又是交互式的，这里再介绍两种工具来处理 ssh 密码输入</p><ul><li><p>sshpass </p></li><li><p>expect</p><p> sshpass 使用非常简单，可以通过 -p 直接输入密码 或者 -f 指定包含密码的文本</p></li></ul><pre class=" language-bash"><code class="language-bash">sshpass -p<span class="token string">'passwd'</span>  <span class="token function">ssh</span> root@serverIp<span class="token comment" spellcheck="true"># 或是</span>sshpass -f ~/.ssh/passwd_file  <span class="token function">ssh</span> root@serverIp</code></pre><p>  expect 可以用来处理交互式的输入，它可以通过匹配正则的方式来发送对应规则的输入，例子如下：</p><pre class=" language-bash"><code class="language-bash">/usr/bin/expect <span class="token operator">&lt;&lt;</span>-EOF<span class="token keyword">set</span> <span class="token function">timeout</span> 30spawn  <span class="token function">scp</span> dist.zip  root@<span class="token variable">${serverIp}</span><span class="token keyword">:</span><span class="token variable">${dstDir}</span><span class="token function">expect</span>  <span class="token string">"*password:"</span>    send <span class="token string">"<span class="token variable">${passwd}</span>\n"</span><span class="token function">expect</span> eof<span class="token keyword">set</span> <span class="token function">timeout</span> 300spawn  <span class="token function">ssh</span>  root@<span class="token variable">${serverIp}</span>  <span class="token string">"cd <span class="token variable">${dstDir}</span>; unzip -o dist.zip"</span><span class="token function">expect</span>  <span class="token string">"*password:"</span>   send <span class="token string">"<span class="token variable">${passwd}</span>\n"</span><span class="token function">expect</span> eofEOF</code></pre><p>综合上面我们就可以完善一个发布上线的脚本：</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># 服务器密码</span>passwd<span class="token operator">=</span><span class="token string">""</span><span class="token comment" spellcheck="true"># 服务器ip</span>serverIp<span class="token operator">=</span><span class="token string">""</span><span class="token comment" spellcheck="true"># 服务器目标目录</span>dstDir<span class="token operator">=</span><span class="token string">""</span><span class="token function">npm</span> run prod<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">!=</span> 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>    <span class="token keyword">echo</span> <span class="token string">"打包失败"</span>    <span class="token keyword">exit</span> 1<span class="token keyword">fi</span><span class="token function">zip</span> -r dist.zip dist/usr/bin/expect <span class="token operator">&lt;&lt;</span>-EOF<span class="token keyword">set</span> <span class="token function">timeout</span> 30spawn  <span class="token function">scp</span> dist.zip  root@<span class="token variable">${serverIp}</span><span class="token keyword">:</span><span class="token variable">${dstDir}</span><span class="token function">expect</span>  <span class="token string">"*password:"</span>    send <span class="token string">"<span class="token variable">${passwd}</span>\n"</span><span class="token function">expect</span> eof<span class="token keyword">set</span> <span class="token function">timeout</span> 300spawn  <span class="token function">ssh</span>  root@<span class="token variable">${serverIp}</span>  <span class="token string">"cd <span class="token variable">${dstDir}</span>; unzip -o dist.zip"</span><span class="token function">expect</span>  <span class="token string">"*password:"</span>   send <span class="token string">"<span class="token variable">${passwd}</span>\n"</span><span class="token function">expect</span> eofEOF</code></pre>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
            <tag> VUE </tag>
            
            <tag> 脚本工具 </tag>
            
            <tag> expect </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
